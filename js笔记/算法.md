## 冒泡排序 ##
**算法思路：**

遍历数组，每次遍历，依次比较相邻的数，每次遍历将最大或最小的值推至最后，越往后，比较的次数越少

    function bubbleSort(arr){
		for(var i=0;i<arr.length;i++){
			for(var j=0;j<arr.length-i;j++)
			{
				if(arr[j]>arr[j+1]){
					var temp=arr[j];
					arr[j]=arr[j+1];
					arr[j+1]=arr[j];
				}
			
			}
		}
		return arr;
	}	

## 快速排序 ##
**算法思路：**

选择数组中间位置的数作为比较的基准，遍历数组，比基准小的，放在一个left的数组，比基准大的，放在一个right数组，然后对分割后的数据再进行上面的操作，使用递归重复这个过程，最后得到排序后的数组

	function quickSort(arr){
	    if(arr.length<=1){
	        return arr;
	    }
	    var middleIndex =Math.floor(arr.length/2);
	    var c=arr.splice(middleIndex,1);
	    var left=[];
	    var right=[];
	    for(var i=0;i<arr.length;i++){
	        if(arr[i]<c){
	            left.push(arr[i]);
	        }
	        else{
	            right.push(arr[i]);
	        }
	    }
    	return quickSort(left).concat(c,quickSort(right));
	} 


## 数组去重 ##
**算法思路**

方法一、从新数组角度考虑，如果新数组中不存在某元素，就将其放进新数组  

    Array.prototype.unique=function(){
		var newArr=[];
		for(var i=0;i<this.length;i++){
			if(newArr.indexOf(this[i])==-1){
				newArr.push(this[i]);
			}
		}
		return newArr;
	}

方法二、从原数组角度考虑，如果元素的索引等于元素第一次出现的索引，就将放进新数组

	Array.prototype.unique=function(){
		var newArr=[this[0]];
		for(var i=1;i<this.length;i++){
			if(this.indexOf(this[i])==i){
				newArr.push(this[i]);
			}
		}
		return newArr;
	} 





